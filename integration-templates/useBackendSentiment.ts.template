/**
 * Backend Sentiment Hook Template
 * 
 * Copy this to your project and customize the connection logic.
 * 
 * INSTRUCTIONS:
 * 1. Update WebSocket/REST URLs to match your backend
 * 2. Adjust error handling/reconnection logic as needed
 * 3. Add authentication if required
 */

import { useState, useEffect, useCallback, useRef } from 'react';
import type { SentimentReading, NarrativeEvent } from '../types/sentiment';
import { adaptToSentimentReading, validateAdaptedReading } from '../adapters/yourBackendAdapter';

interface UseBackendSentimentOptions {
  wsUrl?: string;           // WebSocket URL for real-time stream
  apiUrl?: string;          // REST API URL for polling fallback
  pollInterval?: number;    // Polling interval in ms (default: 1000)
  autoReconnect?: boolean;  // Auto-reconnect on disconnect (default: true)
  reconnectDelay?: number; // Delay before reconnecting (default: 3000)
}

interface UseBackendSentimentReturn {
  reading: SentimentReading | null;
  history: SentimentReading[];
  events: NarrativeEvent[];
  error: Error | null;
  isConnected: boolean;
  reconnect: () => void;
}

export function useBackendSentiment(options: UseBackendSentimentOptions = {}): UseBackendSentimentReturn {
  const {
    wsUrl,
    apiUrl,
    pollInterval = 1000,
    autoReconnect = true,
    reconnectDelay = 3000,
  } = options;
  
  const [reading, setReading] = useState<SentimentReading | null>(null);
  const [history, setHistory] = useState<SentimentReading[]>([]);
  const [events, setEvents] = useState<NarrativeEvent[]>([]);
  const [error, setError] = useState<Error | null>(null);
  const [isConnected, setIsConnected] = useState(false);
  
  const wsRef = useRef<WebSocket | null>(null);
  const reconnectTimeoutRef = useRef<ReturnType<typeof setTimeout> | null>(null);
  const shouldReconnectRef = useRef(true);
  
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // WebSocket Connection
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  
  const connectWebSocket = useCallback(() => {
    if (!wsUrl || wsRef.current?.readyState === WebSocket.OPEN) return;
    
    try {
      // TODO: Add authentication headers if needed
      // const ws = new WebSocket(wsUrl, ['token', yourAuthToken]);
      const ws = new WebSocket(wsUrl);
      
      ws.onopen = () => {
        console.log('âœ… Connected to sentiment stream');
        setIsConnected(true);
        setError(null);
        shouldReconnectRef.current = true;
      };
      
      ws.onmessage = (event) => {
        try {
          const rawData = JSON.parse(event.data);
          const adapted = adaptToSentimentReading(rawData);
          
          // Validate adapted data
          if (!validateAdaptedReading(adapted)) {
            console.warn('âš ï¸ Invalid adapted reading:', adapted);
            return;
          }
          
          setReading(adapted);
          setHistory(prev => [...prev.slice(-499), adapted]);
          
          // Collect narrative events
          if (adapted.narrative) {
            setEvents(prev => [
              { ...adapted.narrative!, timestamp: adapted.timestamp } as NarrativeEvent & { timestamp: number },
              ...prev.filter(e => e.id !== adapted.narrative!.id), // Avoid duplicates
            ].slice(0, 50));
          }
        } catch (err) {
          console.error('âŒ Failed to parse sentiment data:', err);
          setError(err as Error);
        }
      };
      
      ws.onerror = (err) => {
        console.error('âŒ WebSocket error:', err);
        setError(new Error('WebSocket connection error'));
        setIsConnected(false);
      };
      
      ws.onclose = (event) => {
        console.log('ðŸ”Œ WebSocket closed:', event.code, event.reason);
        setIsConnected(false);
        
        // Auto-reconnect if enabled
        if (autoReconnect && shouldReconnectRef.current && event.code !== 1000) {
          reconnectTimeoutRef.current = setTimeout(() => {
            console.log('ðŸ”„ Reconnecting...');
            connectWebSocket();
          }, reconnectDelay);
        }
      };
      
      wsRef.current = ws;
    } catch (err) {
      console.error('âŒ Failed to create WebSocket:', err);
      setError(err as Error);
    }
  }, [wsUrl, autoReconnect, reconnectDelay]);
  
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // REST Polling Fallback
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  
  useEffect(() => {
    // Only use REST if WebSocket is not available
    if (wsUrl || !apiUrl) return;
    
    const fetchData = async () => {
      try {
        // TODO: Add authentication headers if needed
        // const headers = { Authorization: `Bearer ${token}` };
        const response = await fetch(apiUrl);
        
        if (!response.ok) {
          throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }
        
        const rawData = await response.json();
        const adapted = adaptToSentimentReading(rawData);
        
        if (!validateAdaptedReading(adapted)) {
          throw new Error('Invalid data format from backend');
        }
        
        setReading(adapted);
        setHistory(prev => [...prev.slice(-499), adapted]);
        setIsConnected(true);
        setError(null);
      } catch (err) {
        console.error('âŒ Failed to fetch sentiment data:', err);
        setError(err as Error);
        setIsConnected(false);
      }
    };
    
    fetchData(); // Initial fetch
    const interval = setInterval(fetchData, pollInterval);
    
    return () => clearInterval(interval);
  }, [apiUrl, pollInterval, wsUrl]);
  
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // WebSocket Effect
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  
  useEffect(() => {
    if (wsUrl) {
      connectWebSocket();
    }
    
    return () => {
      // Cleanup
      shouldReconnectRef.current = false;
      if (reconnectTimeoutRef.current) {
        clearTimeout(reconnectTimeoutRef.current);
      }
      if (wsRef.current) {
        wsRef.current.close(1000, 'Component unmounting');
      }
    };
  }, [wsUrl, connectWebSocket]);
  
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // Manual Reconnect Function
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  
  const reconnect = useCallback(() => {
    if (wsRef.current) {
      wsRef.current.close();
    }
    shouldReconnectRef.current = true;
    connectWebSocket();
  }, [connectWebSocket]);
  
  return {
    reading,
    history,
    events,
    error,
    isConnected,
    reconnect,
  };
}

